import hashlib
import os
import random
import sys
from collections import OrderedDict
from thompson_sampling.bernoulli import BernoulliExperiment
import gym
import numpy as np
from gym import spaces
from malware_rl.envs.controls import modifier
from malware_rl.envs.utils import interface, sorel
import shap
import pefile

random.seed(0)
module_path = os.path.split(os.path.abspath(sys.modules[__name__].__file__))[0]

ACTION_LOOKUP = {i: act for i, act in enumerate(modifier.ACTION_TABLE.keys())}

sorel_model = sorel.SorelModel()
malicious_threshold = sorel_model.threshold

sorel_model.model.params["objective"] = 'regression'
explainer = shap.TreeExplainer(sorel_model.model)
def cal_feature_shapley(explainer, feature):
    shap_values = explainer.shap_values(np.expand_dims(feature, 0))

    value_bytehistogram = np.mean(shap_values[0, :255])
    value_byteentropyhistogram = np.mean(shap_values[0, 255:511])
    value_stringextractor = np.mean(shap_values[0, 511:615])
    value_generalfileinfo = np.mean(shap_values[0, 615:625])
    value_headerfileinfo = np.mean(shap_values[0, 625:687])
    value_sectioninfo = np.mean(shap_values[0, 688:942])
    value_importsinfo = np.mean(shap_values[0, 942:2222])
    value_exportsinfo = np.mean(shap_values[0, 2222:2350])
    value_datadirecties = np.mean(shap_values[0, 2350:])

    feature_shapley = np.hstack([value_bytehistogram,
                                 value_byteentropyhistogram,
                                 value_stringextractor,
                                 value_generalfileinfo,
                                 value_headerfileinfo,
                                 value_sectioninfo,
                                 value_importsinfo,
                                 value_exportsinfo,
                                 value_datadirecties])

    return feature_shapley

AFFECT_TABLE = [[1, 1, 1, 0, 1, 0, 0, 0, 0],
                [1, 1, 1, 0, 0, 0, 0, 0, 0],
                [1, 1, 1, 0, 1, 0, 0, 0, 0],
                [1, 1, 1, 0, 1, 0, 0, 0, 0],
                [1, 1, 1, 0, 0, 1, 0, 0, 0],
                [1, 1, 1, 0, 1, 0, 0, 0, 0],
                [1, 1, 1, 1, 0, 0, 1, 0, 0],
                [1, 1, 1, 1, 0, 0, 0, 0, 1],
                [1, 1, 1, 0, 0, 0, 0, 0, 0],
                [1, 1, 1, 1, 0, 1, 0, 0, 1]]



class SorelEnv(gym.Env):
    """Creates the Sorel Gym Interface"""

    metadata = {"render.modes": ["human"]}

    def __init__(
        self,
        sha256list,
        random_sample=True,
        maxturns=5,
        output_path="data/evaded/sorel",
    ):
        super().__init__()
        self.available_sha256 = sha256list
        self.action_space = spaces.Discrete(len(ACTION_LOOKUP))
        observation_high = np.finfo(np.float32).max
        self.observation_space = spaces.Box(
            low=-observation_high,
            high=observation_high,
            shape=(2381,),
            dtype=np.float32,
        )
        self.maxturns = maxturns
        self.feature_extractor = sorel_model.extract
        self.output_path = output_path
        self.random_sample = random_sample
        self.history = OrderedDict()
        self.sample_iteration_index = 0

        self.output_path = os.path.join(
            os.path.dirname(
                os.path.dirname(
                    os.path.dirname(
                        os.path.abspath(__file__),
                    ),
                ),
            ),
            output_path,
        )

        self.arms = {'modify_machine_type': BernoulliExperiment(arms=4),
                'modify_optional_header': BernoulliExperiment(arms=6),
                'modify_timestamp': BernoulliExperiment(arms=5),
                'rename_section': BernoulliExperiment(arms=10),
                'add_imports': BernoulliExperiment(arms=16),
                'append_benign_data_overlay': BernoulliExperiment(arms=50),
                'add_section_benign_data': BernoulliExperiment(arms=50),
                'add_bytes_to_section_cave': BernoulliExperiment(arms=50),
                "remove_debug":BernoulliExperiment(arms=1), # return none
                "break_optional_header_checksum": BernoulliExperiment(arms=1)} # return none

        self.explainer = explainer
        self.shapley = None


    def step(self, action_ix):
        # Execute one time step within the environment
        self.turns += 1
        action, arm_pull = self._take_action(action_ix)
        self.observation_space = self.feature_extractor(self.bytez)
        self.score = sorel_model.predict_sample(self.observation_space)

        # update the shapley value per 20 turns
        if (self.turns-1) % 20 == 0:
            feature_shapley = cal_feature_shapley(self.explainer, self.observation_space)
            threshlod = list(set(feature_shapley))[-3]
            select_shapley = np.where(feature_shapley < threshlod, 0, feature_shapley)
            prior = [sum(f * select_shapley) for f in AFFECT_TABLE]
            p_shapley = [1 / (r + 1) for r in np.argsort(prior)]
            self.p_shapley = p_shapley / sum(p_shapley)


        if self.score < malicious_threshold:
            reward = 10.0
            episode_over = True
            self.history[self.sha256]["evaded"] = True
            self.history[self.sha256]["reward"] = reward

            # save off file to evasion directory
            m = hashlib.sha256()
            m.update(self.bytez)
            sha256 = m.hexdigest()
            evade_path = os.path.join(self.output_path, sha256)

            with open(evade_path, "wb") as out:
                out.write(self.bytez)

            # verify action changes
            try:
                pefile.PE(evade_path)

                episode_over = True
                self.history[self.sha256]["evaded"] = True
                self.history[self.sha256]["reward"] = reward

                self.history[self.sha256]["evade_path"] = evade_path

            except Exception as e:
                print('pefile parse fail')

                episode_over = True
                self.history[self.sha256]["evaded"] = False
                self.history[self.sha256]["reward"] = 0

        elif self.turns >= self.maxturns:
            # game over - max turns hit
            reward = self.original_score - self.score
            episode_over = True
            self.history[self.sha256]["evaded"] = False
            self.history[self.sha256]["reward"] = reward
        else:
            reward = self.original_score - self.score
            episode_over = False


        #  update thompson sample
        if arm_pull != "no arm" and abs(reward) > 0.001:
            arm_info = [{"label": arm_pull, "reward": max(np.sign(reward), 0)}]
            self.arms[action].add_rewards(arm_info)


        if episode_over:
            print(f"Episode over: reward = {reward}")

        return self.observation_space, reward, episode_over, self.history[self.sha256]

    def _take_action(self, action_ix):
        action = ACTION_LOOKUP[action_ix]

        arm = self.arms[action]
        self.history[self.sha256]["actions"].append(action)
        self.bytez, arm_pull = modifier.modify_sample(self.bytez, action, arm)
        return action, arm_pull

    def reset(self):
        # Reset the state of the environment to an initial state
        self.turns = 0
        while True:
            # grab a new sample (TODO)
            if self.random_sample:
                self.sha256 = random.choice(self.available_sha256)
            else:
                self.sha256 = self.available_sha256[
                    self.sample_iteration_index % len(self.available_sha256)
                ]
                self.sample_iteration_index += 1

            self.history[self.sha256] = {"actions": [], "evaded": False}
            self.bytez = interface.fetch_file(
                os.path.join(
                    module_path,
                    "utils/samples/",
                )
                + self.sha256,
            )

            self.observation_space = self.feature_extractor(self.bytez)
            self.original_score = sorel_model.predict_sample(
                self.observation_space,
            )

            feature_shapley = cal_feature_shapley(self.explainer, self.observation_space)
            threshlod = list(set(feature_shapley))[-3]
            select_shapley = np.where(feature_shapley < threshlod, 0, feature_shapley)
            prior = [sum(f * select_shapley) for f in AFFECT_TABLE]

            p_shapley = [1 / (r + 1) for r in np.argsort(prior)]
            self.p_shapley = p_shapley / sum(p_shapley)

            if self.original_score < malicious_threshold:
                # already labeled benign, skip
                continue
            break
        print(f"Sample: {self.sha256}")
        return self.observation_space, self.p_shapley


    def render(self, mode="human", close=False):
        # Render the environment to the screen
        pass
